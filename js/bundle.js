/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var apca_w3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apca-w3 */ \"./node_modules/apca-w3/src/apca-w3.js\");\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  var generateBtn = document.getElementById('generateBtn');\n  if (!generateBtn) {\n    console.error('Generate button not found in the DOM.');\n    return;\n  }\n  generateBtn.addEventListener('click', function () {\n    var baseColor = document.getElementById('baseColor').value.trim();\n    if (!baseColor) return alert('Please enter a color.');\n    var paletteDiv = document.getElementById('palette');\n    paletteDiv.innerHTML = ''; // Clear previous palette\n\n    try {\n      // Your color generation logic here\n      console.log('Color generation would occur here');\n    } catch (error) {\n      alert('Error generating colors.');\n      console.error(error);\n    }\n  });\n});\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./node_modules/apca-w3/src/apca-w3.js":
/*!*********************************************!*\
  !*** ./node_modules/apca-w3/src/apca-w3.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APCAcontrast: () => (/* binding */ APCAcontrast),\n/* harmony export */   adobeRGBtoY: () => (/* binding */ adobeRGBtoY),\n/* harmony export */   alphaBlend: () => (/* binding */ alphaBlend),\n/* harmony export */   calcAPCA: () => (/* binding */ calcAPCA),\n/* harmony export */   displayP3toY: () => (/* binding */ displayP3toY),\n/* harmony export */   fontLookupAPCA: () => (/* binding */ fontLookupAPCA),\n/* harmony export */   reverseAPCA: () => (/* binding */ reverseAPCA),\n/* harmony export */   sRGBtoY: () => (/* binding */ sRGBtoY)\n/* harmony export */ });\n/* harmony import */ var colorparsley__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colorparsley */ \"./node_modules/colorparsley/src/colorparsley.js\");\n///////////////////////////////////////////////////////////////////////////////\n/** @preserve\n/////    SAPC APCA - Advanced Perceptual Contrast Algorithm\n/////           Beta 0.1.9 W3 ‚Ä¢ contrast function only\n/////           DIST: W3 ‚Ä¢ Revision date: July 3, 2022\n/////    Function to parse color values and determine Lc contrast\n/////    Copyright ¬© 2019-2022 by Andrew Somers. All Rights Reserved.\n/////    LICENSE: W3 LICENSE\n/////    CONTACT: Please use the ISSUES or DISCUSSIONS tab at:\n/////    https://github.com/Myndex/SAPC-APCA/\n/////\n///////////////////////////////////////////////////////////////////////////////\n/////\n/////    MINIMAL IMPORTS:\n/////      import { APCAcontrast, sRGBtoY, displayP3toY,\n/////               calcAPCA, fontLookupAPCA } from 'apca-w3';\n/////      import { colorParsley } from 'colorparsley';\n/////\n/////    FORWARD CONTRAST USAGE:\n/////      Lc = APCAcontrast( sRGBtoY( TEXTcolor ) , sRGBtoY( BACKGNDcolor ) );\n/////    Where the colors are sent as an rgba array [255,255,255,1]\n/////\n/////    Retrieving an array of font sizes for the contrast:\n/////      fontArray = fontLookupAPCA(Lc);\n/////\n/////    Live Demonstrator at https://www.myndex.com/APCA/\n// */\n///////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n/////\n/////                  SAPC Method and APCA Algorithm\n/////   W3 Licensed Version: https://github.com/Myndex/apca-w3\n/////   GITHUB MAIN REPO: https://github.com/Myndex/SAPC-APCA\n/////   DEVELOPER SITE: https://git.myndex.com/\n/////\n/////   Acknowledgments and Thanks To:\n/////   ‚Ä¢ This project references the research & work of M.Fairchild, R.W.Hunt,\n/////     Drs. Bailey/Lovie-Kitchin, G.Legge, A.Arditi, M.Stone, C.Poynton, \n/////     L.Arend, M.Luo, E.Burns, R.Blackwell, P.Barton, M.Brettel, and many \n/////     others ‚Äî see refs at https://www.myndex.com/WEB/WCAG_CE17polarity\n/////   ‚Ä¢ Bruce Bailey of USAccessBoard for his encouragement, ideas, & feedback\n/////   ‚Ä¢ Chris Lilly of W3C for continued review, examination, & oversight\n/////   ‚Ä¢ Chris Loiselle of Oracle for getting us back on track in a pandemic\n/////   ‚Ä¢ The many volunteer test subjects for participating in the studies.\n/////   ‚Ä¢ The many early adopters, beta testers, and code/issue contributors\n/////   ‚Ä¢ Principal research conducted at Myndex by A.Somers.\n/////\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n/////\n/////   *****  SAPC BLOCK  *****\n/////\n/////   For Evaluations, refer to this as: SAPC-8, 0.0.98G-series constant 4g\n/////            SAPC ‚Ä¢ S-LUV Advanced Predictive Color\n/////\n/////   SIMPLE VERSION ‚Äî Only the basic APCA contrast predictor.\n/////\n/////   Included Extensions & Model Features in this file:\n/////       ‚Ä¢ SAPC-8 Core Contrast (Base APCA, non-clinical use only) \n/////       ‚Ä¢ G series constants, group \"G-4g\" using a 2.4 monitor exponent\n/////       ‚Ä¢ sRGB to Y, parses numeric sRGB color to luminance\n/////       ‚Ä¢ SoftToe black level soft clamp and flare compensation.\n/////\n/////\n////////////////////////////////////////////////////////////////////////////////\n/////\n/////               DISCLAIMER AND LIMITATIONS OF USE\n/////     APCA is an embodiment of certain suprathreshold contrast\n/////     prediction technologies and it is licensed to the W3 on a\n/////     limited basis for use in certain specific accessibility\n/////     guidelines for web content only. APCA may be used for \n/////     predicting colors for web content use without royalty.\n/////\n/////     However, Any such license excludes other use cases\n/////     not related to web content. Prohibited uses include\n/////     medical, clinical evaluation, human safety related,\n/////     aerospace, transportation, military applications, \n/////     and uses which are not specific to web based content\n/////     presented on self-illuminated displays or devices.\n/////\n////////////////////////////////////////////////////////////////////////////////\n\n//////////   APCA 0.1.9  G 4g USAGE  ///////////////////////////////////////////\n///\n///  The API for \"APCA 0.1.9\" is trivially simple.\n///  Send text and background sRGB numeric values to the sRGBtoY() function,\n///  and send the resulting text-Y and background-Y to the APCAcontrast function\n///  it returns a signed float with the numeric Lc contrast result.\n///  \n///  The two inputs are TEXT color and BACKGROUND color in that order.\n///  Each must be a numeric NOT a string, as this simple version has\n///  no string parsing utilities. EXAMPLE:\n///  ________________________________________________________________________\n///\n///     txtColor = colorParsley(0x123456); // color of the text\n///     bgColor  = colorParsley(0xabcdef); // color for the background\n///\n///     contrastLc = APCAcontrast( sRGBtoY(txtColor) , sRGBtoY(bgColor) );\n///  ________________________________________________________________________\n///\n///                  **********   QUICK START   **********\n///\n///  Each color must be a 24bit color (8 bit per channel) as a single integer\n///  (or 0x) sRGB encoded color, i.e. White is either the integer 16777216 or\n///  the hex 0xffffff. A float is returned with a positive or negative value.\n///  Negative values mean light text and a dark background, positive values\n///  mean dark text and a light background. 60.0, or -60.0 is a contrast\n///  \"sort of like\" the old WCAG 2's 4.5:1. NOTE: the total range is now less\n///  than ¬± 110, so output can be rounded to a signed INT but DO NOT output\n///  an absolute value - light text on dark BG should return a negative number.\n///\n///     *****  IMPORTANT: Do Not Mix Up Text and Background inputs.  *****\n///     ****************   APCA is polarity sensitive!   *****************\n///  \n////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n/////    BEGIN APCA  0.1.9  BLOCK       \\/////////////////////////////////////\n////                                     \\///////////////////////////////////\n///                                       \\/////////////////////////////////\n//                                         \\///////////////////////////////\n\n\n/////  DEPENDENCIES  /////\n\n// The following imports are not needed for the main APCA function,\n// but are needed for the shortcut/alias calcAPCA(), and for the\n// future invertAPCA function, which examines hue.\n\n       ////  (add slash to line start for local test mode, remove before push)\n/*    ////  LOCAL TESTING SWITCH for using test.html\n    import{colorParsley}from'../node_modules/colorparsley/src/colorparsley.js';\n/*/   //// TOGGLE\n    \n// */ //// END LOCAL TESTING SWITCH\n\n\n/////  Module Scope Object Containing Constants  /////\n/////   APCA   0.0.98G - 4g - W3 Compatible Constants\n\n/////  ùí¶ SA98G  ///////////////////////////////////\n    const SA98G = {\n\n        mainTRC: 2.4, // 2.4 exponent for emulating actual monitor perception\n\n            // For reverseAPCA\n        get mainTRCencode() { return 1 / this.mainTRC },\n\n              // sRGB coefficients\n        sRco: 0.2126729, \n        sGco: 0.7151522, \n        sBco: 0.0721750, \n\n              // G-4g constants for use with 2.4 exponent\n        normBG: 0.56, \n        normTXT: 0.57,\n        revTXT: 0.62,\n        revBG: 0.65,\n\n              // G-4g Clamps and Scalers\n        blkThrs: 0.022,\n        blkClmp: 1.414, \n        scaleBoW: 1.14,\n        scaleWoB: 1.14,\n        loBoWoffset: 0.027,\n        loWoBoffset: 0.027,\n        deltaYmin: 0.0005,\n        loClip: 0.1,\n\n          ///// MAGIC NUMBERS for UNCLAMP, for use with 0.022 & 1.414 /////\n         // Magic Numbers for reverseAPCA\n        mFactor: 1.94685544331710,\n        get mFactInv() { return 1 / this.mFactor},\n        mOffsetIn: 0.03873938165714010,\n        mExpAdj: 0.2833433964208690,\n        get mExp() { return this.mExpAdj / this.blkClmp},\n        mOffsetOut: 0.3128657958707580,\n      }\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////  APCA CALCULATION FUNCTIONS \\/////////////////////////////////////\n\n//////////  ∆í  APCAcontrast()  ////////////////////////////////////////////\nfunction APCAcontrast (txtY,bgY,places = -1) {\n                 // send linear Y (luminance) for text and background.\n                // txtY and bgY must be between 0.0-1.0\n               // IMPORTANT: Do not swap, polarity is important.\n\n  const icp = [0.0,1.1];     // input range clamp / input error check\n\n  if(isNaN(txtY)||isNaN(bgY)||Math.min(txtY,bgY)<icp[0]||\n                              Math.max(txtY,bgY)>icp[1]){\n    return 0.0;  // return zero on error\n    // return 'error'; // optional string return for error\n  };\n\n//////////   SAPC LOCAL VARS   /////////////////////////////////////////\n\n  let SAPC = 0.0;            // For raw SAPC values\n  let outputContrast = 0.0; // For weighted final values\n  let polCat = 'BoW';      // Alternate Polarity Indicator. N normal R reverse\n\n  // TUTORIAL\n\n  // Use Y for text and BG, and soft clamp black,\n  // return 0 for very close luminances, determine\n  // polarity, and calculate SAPC raw contrast\n  // Then scale for easy to remember levels.\n\n  // Note that reverse contrast (white text on black)\n  // intentionally returns a negative number\n  // Proper polarity is important!\n\n//////////   BLACK SOFT CLAMP   ////////////////////////////////////////\n\n          // Soft clamps Y for either color if it is near black.\n  txtY = (txtY > SA98G.blkThrs) ? txtY :\n                         txtY + Math.pow(SA98G.blkThrs - txtY, SA98G.blkClmp);\n  bgY = (bgY > SA98G.blkThrs) ? bgY :\n                          bgY + Math.pow(SA98G.blkThrs - bgY, SA98G.blkClmp);\n\n       ///// Return 0 Early for extremely low ‚àÜY\n  if ( Math.abs(bgY - txtY) < SA98G.deltaYmin ) { return 0.0; }\n\n\n//////////   APCA/SAPC CONTRAST - LOW CLIP (W3 LICENSE)  ///////////////\n\n  if ( bgY > txtY ) {  // For normal polarity, black text on white (BoW)\n\n              // Calculate the SAPC contrast value and scale\n    SAPC = ( Math.pow(bgY, SA98G.normBG) - \n             Math.pow(txtY, SA98G.normTXT) ) * SA98G.scaleBoW;\n\n            // Low Contrast smooth rollout to prevent polarity reversal\n           // and also a low-clip for very low contrasts\n    outputContrast = (SAPC < SA98G.loClip) ? 0.0 : SAPC - SA98G.loBoWoffset;\n\n  } else {  // For reverse polarity, light text on dark (WoB)\n           // WoB should always return negative value.\n    polCat = 'WoB';\n\n    SAPC = ( Math.pow(bgY, SA98G.revBG) - \n             Math.pow(txtY, SA98G.revTXT) ) * SA98G.scaleWoB;\n\n    outputContrast = (SAPC > -SA98G.loClip) ? 0.0 : SAPC + SA98G.loWoBoffset;\n  }\n\n         // return Lc (lightness contrast) as a signed numeric value \n        // Round to the nearest whole number as string is optional.\n       // Rounded can be a signed INT as output will be within ¬± 127 \n      // places = -1 returns signed float, 1 or more set that many places\n     // 0 returns rounded string, uses BoW or WoB instead of minus sign\n\n  if(places < 0 ){  // Default (-1) number out, all others are strings\n    return  outputContrast * 100.0;\n  } else if(places == 0 ){\n    return  Math.round(Math.abs(outputContrast)*100.0)+'<sub>'+polCat+'</sub>';\n  } else if(Number.isInteger(places)){\n    return  (outputContrast * 100.0).toFixed(places);\n  } else { return 0.0 }\n\n} // End APCAcontrast()\n\n\n\n\n/*  SWITCH -- WORK IN PROGRESS DO NOT USE\n//////////  ∆í  invertAPCA()  //////////////////////////////////////////////////\nexport function invertAPCA (\n      {knownColor: [128,128,128], knownType: 'bg', targetCnst: 75,\n       returnAs: 'object', unknownType: 'txt', hueInvert: false,\n       hueRange: 5, preserveSat: false }) {\n\n  //if (Math.abs(targetCnst) < 15) { return false }; // abs contrast must be > 15\n\n  let knownY = sRGBtoY (knownColor);\n  let unknownY = knownY, knownExp, unknownExp;\n  let min,max,knownLs,isBG = true;\n\n\n  if (knownType == 'bg' || knownType == 'background') {\n    knownLs = Math.pow(knownY, );\n    black = APCAcontrast(0,knownY);\n    white = APCAcontrast(1,knownY);\n  } else if  (knownType == 'txt' || knownType == 'text') {\n    isBG = false;\n    black = APCAcontrast(knownY,0);\n    white = APCAcontrast(knownY,1);\n  } else { return false } // return false on error\n\n\n/////   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////\n\n  const scale = contrast > 0 ? SA98G.scaleBoW : SA98G.scaleWoB;\n  const offset = contrast > 0 ? SA98G.loBoWoffset : -SA98G.loWoBoffset;\n\n\n    targetCnst = ( parseFloat(targetCnst) * 0.01 + offset ) / scale;\n\n              // Soft clamps Y if it is near black.\n    knownY = (knownY > SA98G.blkThrs) ? knownY :\n              knownY + Math.pow(SA98G.blkThrs - knownY, SA98G.blkClmp);\n                                  \n       // set the known and unknown exponents\n    if (isBG) {\n        knownExp = targetCnst > 0 ? SA98G.normBG : SA98G.revBG;\n        unknownExp = targetCnst > 0 ? SA98G.normTXT : SA98G.revTXT;\n        unknownY = Math.pow( Math.pow(knownY,knownExp) - targetCnst, 1/unknownExp );\n        if (isNaN(unknownY)) return false;\n    } else if (!isBG) {\n        knownExp = targetCnst > 0 ? SA98G.normTXT : SA98G.revTXT;\n        unknownExp = targetCnst > 0 ? SA98G.normBG : SA98G.revBG;\n        unknownY = Math.pow(targetCnst + Math.pow(knownY,knownExp), 1/unknownExp );\n        if (isNaN(unknownY)) return false;\n    }\n\n    //return contrast +'----'+unknownY;\n\n    if (unknownY > 1.06 || unknownY < 0) { return false } // return false on overflow\n    // if (unknownY < 0) { return false } // return false on underflow\n    //unknownY = Math.max(unknownY,0.0);\n    \n                //  unclamp\n    unknownY = (unknownY > SA98G.blkThrs) ? unknownY : \n    (Math.pow(((unknownY + SA98G.mOffsetIn)m* SA98G.mFactor),\n                           SA98G.mExp) * SA98G.mFactInv) - SA98G.mOffsetOut;\n    \n//    unknownY - 0.22 * Math.pow(unknownY*0.5, 1/blkClmp);\n\n    unknownY = Math.max(Math.min(unknownY,1.0),0.0);\n\n    let testedCnst = (isBG) ? APCAcontrast(unknownY,knownY) : \n                              APCAcontrast(knownY,unknownY);\n\n  if (returnAs === 'object') {\n    let hexB = ( Math.round(Math.pow(unknownY,SA98G.mainTRCencode) * 255)\n                ).toString(16).padStart(2,'0');\n    hexB = '#' + hexB + hexB + hexB;\n    return  {color: hexB, Lc: testedCnst, whiteLc: white, blackLc: black};\n  } else if (returnAs === 'hex') {\n    let hexB = ( Math.round(Math.pow(unknownY,SA98G.mainTRCencode) * 255)\n                ).toString(16).padStart(2,'0');\n    return  '#' + hexB + hexB + hexB;\n  } else if (returnAs === 'array') {\n    let colorB = Math.round(Math.pow(unknownY,SA98G.mainTRCencode) * 255);\n    let retUse = (knownType == 'bg') ? 'txtColor' : 'bgColor'\n    return  [colorB,colorB,colorB,1,retUse];\n  } else if (returnAs === 'Y' || returnAs === 'y') {\n    return  Math.max(0.0,unknownY);\n  } else { return false } // return knownY on error\n}\n//  */  // END SWITCH\n\n\n\n\n//////////  ∆í  reverseAPCA() DEPRECATED SOON ///////////////////////////////\nfunction reverseAPCA (contrast = 0,knownY = 1.0,\n                             knownType = 'bg',returnAs = 'hex') {\n    \n  if (Math.abs(contrast) < 9) { return false }; // abs contrast must be > 9\n  \n  let unknownY = knownY, knownExp, unknownExp;\n  \n/////   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////\n\n  const scale = contrast > 0 ? SA98G.scaleBoW : SA98G.scaleWoB;\n  const offset = contrast > 0 ? SA98G.loBoWoffset : -SA98G.loWoBoffset;\n\n\n  contrast = ( parseFloat(contrast) * 0.01 + offset ) / scale;\n\n            // Soft clamps Y if it is near black.\n  knownY = (knownY > SA98G.blkThrs) ? knownY :\n            knownY + Math.pow(SA98G.blkThrs - knownY, SA98G.blkClmp);\n                                \n     // set the known and unknown exponents\n  if (knownType == 'bg' || knownType == 'background') {\n      knownExp = contrast > 0 ? SA98G.normBG : SA98G.revBG;\n      unknownExp = contrast > 0 ? SA98G.normTXT : SA98G.revTXT;\n      unknownY = Math.pow( Math.pow(knownY,knownExp) - contrast, 1/unknownExp );\n      if (isNaN(unknownY)) return false;\n  } else if (knownType == 'txt' || knownType == 'text') {\n      knownExp = contrast > 0 ? SA98G.normTXT : SA98G.revTXT;\n      unknownExp = contrast > 0 ? SA98G.normBG : SA98G.revBG;\n      unknownY = Math.pow(contrast + Math.pow(knownY,knownExp), 1/unknownExp );\n      if (isNaN(unknownY)) return false;\n  } else { return false } // return false on error\n\n  //return contrast +'----'+unknownY;\n\n  if (unknownY > 1.06 || unknownY < 0) { return false } // return false on overflow\n  // if (unknownY < 0) { return false } // return false on underflow\n  //unknownY = Math.max(unknownY,0.0);\n  \n              //  unclamp\n  unknownY = (unknownY > SA98G.blkThrs) ? unknownY : \n  (Math.pow(((unknownY + SA98G.mOffsetIn) * SA98G.mFactor),\n                         SA98G.mExp) * SA98G.mFactInv) - SA98G.mOffsetOut;\n  \n//    unknownY - 0.22 * Math.pow(unknownY*0.5, 1/blkClmp);\n\n  unknownY = Math.max(Math.min(unknownY,1.0),0.0);\n\n  if (returnAs === 'hex') {\n    let hexB = ( Math.round(Math.pow(unknownY,SA98G.mainTRCencode) * 255)\n                ).toString(16).padStart(2,'0');\n\n    return  '#' + hexB + hexB + hexB;\n  } else if (returnAs === 'color') {\n    let colorB = Math.round(Math.pow(unknownY,SA98G.mainTRCencode) * 255);\n    let retUse = (knownType == 'bg') ? 'txtColor' : 'bgColor'\n    return  [colorB,colorB,colorB,1,retUse];\n  } else if (returnAs === 'Y' || returnAs === 'y') {\n    return  Math.max(0.0,unknownY);\n  } else { return false } // return knownY on error\n}\n\n\n\n\n//////////  ∆í  calcAPCA()  /////////////////////////////////////////////\nfunction calcAPCA (textColor, bgColor, places = -1, round = true) {\n\n        // Note that this function requires colorParsley !!\n\tlet bgClr = (0,colorparsley__WEBPACK_IMPORTED_MODULE_0__.colorParsley)(bgColor);\n\tlet txClr = (0,colorparsley__WEBPACK_IMPORTED_MODULE_0__.colorParsley)(textColor);\n\tlet hasAlpha = (txClr[3] == '' || txClr[3] == 1) ? false : true ;\n\n\tif (hasAlpha) { txClr = alphaBlend( txClr, bgClr, round); };\n\n\treturn APCAcontrast( sRGBtoY(txClr), sRGBtoY(bgClr), places)\n} // End calcAPCA()\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////  ∆í  fontLookupAPCA()  0.1.7 (G)  \\////////////////////////////////\n/////////                                    \\//////////////////////////////\n\nfunction fontLookupAPCA (contrast,places=2) {\n\n////////////////////////////////////////////////////////////////////////////\n/////  CONTRAST * FONT WEIGHT & SIZE  /////////////////////////////////////\n\n// Font size interpolations. Here the chart was re-ordered to put\n// the main contrast levels each on one line, instead of font size per line.\n// First column is LC value, then each following column is font size by weight\n\n// G G G G G G  Public Beta 0.1.7 (G) ‚Ä¢ MAY 28 2022\n\n// Lc values under 70 should have Lc 15 ADDED if used for body text\n// All font sizes are in px and reference font is Barlow\n\n// 999: prohibited - too low contrast\n// 777: NON TEXT at this minimum weight stroke\n// 666 - this is for spot text, not fluent-Things like copyright or placeholder.\n// 5xx - minimum font at this weight for content, 5xx % 500 for font-size\n// 4xx - minimum font at this weight for any purpose], 4xx % 400 for font-size\n\n// MAIN FONT SIZE LOOKUP\n\n//// ASCENDING SORTED  Public Beta 0.1.7 (G) ‚Ä¢ MAY 28 2022  ////\n\n//// Lc 45 * 0.2 = 9 which is the index for the row for Lc 45\n\n// MAIN FONT LOOKUP May 28 2022 EXPANDED\n// Sorted by Lc Value\n// First row is standard weights 100-900\n// First column is font size in px\n// All other values are the Lc contrast \n// 999 = too low. 777 = non-text and spot text only\n\n\nconst fontMatrixAscend = [\n    ['Lc',100,200,300,400,500,600,700,800,900],\n    [0,999,999,999,999,999,999,999,999,999],\n    [10,999,999,999,999,999,999,999,999,999],\n    [15,777,777,777,777,777,777,777,777,777],\n    [20,777,777,777,777,777,777,777,777,777],\n    [25,777,777,777,120,120,108,96,96,96],\n    [30,777,777,120,108,108,96,72,72,72],\n    [35,777,120,108,96,72,60,48,48,48],\n    [40,120,108,96,60,48,42,32,32,32],\n    [45,108,96,72,42,32,28,24,24,24],\n    [50,96,72,60,32,28,24,21,21,21],\n    [55,80,60,48,28,24,21,18,18,18],\n    [60,72,48,42,24,21,18,16,16,18],\n    [65,68,46,32,21.75,19,17,15,16,18],\n    [70,64,44,28,19.5,18,16,14.5,16,18],\n    [75,60,42,24,18,16,15,14,16,18],\n    [80,56,38.25,23,17.25,15.81,14.81,14,16,18],\n    [85,52,34.5,22,16.5,15.625,14.625,14,16,18],\n    [90,48,32,21,16,15.5,14.5,14,16,18],\n    [95,45,28,19.5,15.5,15,14,13.5,16,18],\n    [100,42,26.5,18.5,15,14.5,13.5,13,16,18],\n    [105,39,25,18,14.5,14,13,12,16,18],\n    [110,36,24,18,14,13,12,11,16,18],\n    [115,34.5,22.5,17.25,12.5,11.875,11.25,10.625,14.5,16.5],\n    [120,33,21,16.5,11,10.75,10.5,10.25,13,15],\n    [125,32,20,16,10,10,10,10,12,14],\n    ];\n\n\n// ASCENDING SORTED  Public Beta 0.1.7 (G) ‚Ä¢ MAY 28 2022 ////\n\n// DELTA - MAIN FONT LOOKUP May 28 2022 EXPANDED\n// EXPANDED  Sorted by Lc Value ‚Ä¢‚Ä¢  DELTA\n// The pre-calculated deltas of the above array\n\nconst fontDeltaAscend = [\n    ['‚àÜLc',100,200,300,400,500,600,700,800,900],\n    [0,0,0,0,0,0,0,0,0,0],\n    [10,0,0,0,0,0,0,0,0,0],\n    [15,0,0,0,0,0,0,0,0,0],\n    [20,0,0,0,0,0,0,0,0,0],\n    [25,0,0,0,12,12,12,24,24,24],\n    [30,0,0,12,12,36,36,24,24,24],\n    [35,0,12,12,36,24,18,16,16,16],\n    [40,12,12,24,18,16,14,8,8,8],\n    [45,12,24,12,10,4,4,3,3,3],\n    [50,16,12,12,4,4,3,3,3,3],\n    [55,8,12,6,4,3,3,2,2,0],\n    [60,4,2,10,2.25,2,1,1,0,0],\n    [65,4,2,4,2.25,1,1,0.5,0,0],\n    [70,4,2,4,1.5,2,1,0.5,0,0],\n    [75,4,3.75,1,0.75,0.188,0.188,0,0,0],\n    [80,4,3.75,1,0.75,0.188,0.188,0,0,0],\n    [85,4,2.5,1,0.5,0.125,0.125,0,0,0],\n    [90,3,4,1.5,0.5,0.5,0.5,0.5,0,0],\n    [95,3,1.5,1,0.5,0.5,0.5,0.5,0,0],\n    [100,3,1.5,0.5,0.5,0.5,0.5,1,0,0],\n    [105,3,1,0,0.5,1,1,1,0,0],\n    [110,1.5,1.5,0.75,1.5,1.125,0.75,0.375,1.5,1.5],\n    [115,1.5,1.5,0.75,1.5,1.125,0.75,0.375,1.5,1.5],\n    [120,1,1,0.5,1,0.75,0.5,0.25,1,1],\n    [125,0,0,0,0,0,0,0,0,0],\n    ];\n\n  // APCA CONTRAST FONT LOOKUP TABLES\n  // Copyright ¬© 2022 by Myndex Research and Andrew Somers. All Rights Reserved\n  // Public Beta 0.1.7 (G) ‚Ä¢ MAY 28 2022\n  // For the following arrays, the Y axis is contrastArrayLen\n  // The two x axis are weightArrayLen and scoreArrayLen\n\n  // MAY 28 2022\n\n  const weightArray = [0,100,200,300,400,500,600,700,800,900];\n  const weightArrayLen = weightArray.length; // X axis\n\n  let returnArray = [contrast.toFixed(places),0,0,0,0,0,0,0,0,0,];\n  const returnArrayLen = returnArray.length; // X axis\n\n\n  const contrastArrayAscend = ['lc',0,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,];\n  const contrastArrayLenAsc = contrastArrayAscend.length; // Y azis\n\n//// Lc 45 * 0.2 = 9, and 9 is the index for the row for Lc 45\n\n  let tempFont = 777;\n  contrast = Math.abs(contrast); // Polarity unneeded for LUT\n  const factor = 0.2; // 1/5 as LUT is in increments of 5\n  const index = (contrast == 0) ?\n                 1 : (contrast * factor) | 0 ; // LUT row... n|0 is bw floor\n  let w = 0; \n    // scoreAdj interpolates the needed font side per the Lc\n  let scoreAdj = (contrast - fontMatrixAscend[index][w]) * factor;\n\n  w++; // determines column in font matrix LUT\n\n\n/////////  Font and Score Interpolation  \\/////////////////////////////////\n\n// populate returnArray with interpolated values\n\n  for (; w < weightArrayLen; w++) {\n\n    tempFont = fontMatrixAscend[index][w]; \n\n    if (tempFont > 400) { // declares a specific minimum for the weight.\n        returnArray[w] = tempFont;\n    } else if (contrast < 14.5 ) {\n        returnArray[w] = 999; //  999 = do not use for anything\n    } else if (contrast < 29.5 ) {\n        returnArray[w] = 777; // 777 =  non-text only\n    } else {\n                // INTERPOLATION OF FONT SIZE\n               // sets level for 0.5px size increments of smaller fonts\n              // Note bitwise (n|0) instead of floor\n      (tempFont > 24) ?\n        returnArray[w] =\n            Math.round(tempFont - (fontDeltaAscend[index][w] * scoreAdj)) :\n        returnArray[w] =\n            tempFont - ((2.0 * fontDeltaAscend[index][w] * scoreAdj) | 0) * 0.5;\n                                                      // (n|0) is bitwise floor\n    }\n  }\n/////////  End Interpolation  ////////////////////////////////////////////\n\n  return returnArray\n} // end fontLookupAPCA\n\n/////////\\                                      ///////////////////////////\\\n//////////\\  END  fontLookupAPCA()  0.1.7 (G)  /////////////////////////////\\\n/////////////////////////////////////////////////////////////////////////////\\\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////  LUMINANCE CONVERTERS  |//////////////////////////////////////////\n\n\n//////////  ∆í  sRGBtoY()  //////////////////////////////////////////////////\nfunction sRGBtoY (rgb = [0,0,0]) { // send sRGB 8bpc (0xFFFFFF) or string\n\n// NOTE: Currently expects 0-255\n\n/////   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////\n/*\nconst mainTRC = 2.4; // 2.4 exponent emulates actual monitor perception\n    \nconst sRco = 0.2126729, \n      sGco = 0.7151522, \n      sBco = 0.0721750; // sRGB coefficients\n      */\n// Future:\n// 0.2126478133913640\t0.7151791475336150\t0.0721730390750208\n// Derived from:\n// xW\tyW\tK\txR\tyR\txG\tyG\txB\tyB\n// 0.312720\t0.329030\t6504\t0.640\t0.330\t0.300\t0.600\t0.150\t0.060\n\n         // linearize r, g, or b then apply coefficients\n        // and sum then return the resulting luminance\n\n  function simpleExp (chan) { return Math.pow(chan/255.0, SA98G.mainTRC); };\n\n  return SA98G.sRco * simpleExp(rgb[0]) +\n         SA98G.sGco * simpleExp(rgb[1]) +\n         SA98G.sBco * simpleExp(rgb[2]);\n         \n} // End sRGBtoY()\n\n\n\n\n//////////  ∆í  displayP3toY()  /////////////////////////////////////////////\nfunction displayP3toY (rgb = [0,0,0]) { // send rgba array\n\n// NOTE: Currently Apple has the tuple as 0.0 to 1.0, NOT 255\n\n/////   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////\n\nconst mainTRC = 2.4; // 2.4 exponent emulates actual monitor perception\n                    // Pending evaluation, because, Apple...\n    \nconst sRco = 0.2289829594805780, \n      sGco = 0.6917492625852380, \n      sBco = 0.0792677779341829; // displayP3 coefficients\n\n// Derived from:\n// xW\tyW\tK\txR\tyR\txG\tyG\txB\tyB\n// 0.312720\t0.329030\t6504\t0.680\t0.320\t0.265\t0.690\t0.150\t0.060\n\n         // linearize r, g, or b then apply coefficients\n        // and sum then return the resulting luminance\n\n  function simpleExp (chan) { return Math.pow(chan, mainTRC); };\n\n  return sRco * simpleExp(rgb[0]) +\n         sGco * simpleExp(rgb[1]) +\n         sBco * simpleExp(rgb[2]);\n\n} // End displayP3toY()\n\n\n\n\n//////////  ∆í  adobeRGBtoY()  /////////////////////////////////////////////\nfunction adobeRGBtoY (rgb = [0,0,0]) { // send rgba array\n\n// NOTE: Currently expects 0-255\n\n/////   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////\n\nconst mainTRC = 2.35; // 2.35 exponent emulates actual monitor perception\n                     // Pending evaluation...\n    \nconst sRco = 0.2973550227113810, \n      sGco = 0.6273727497145280, \n      sBco = 0.0752722275740913; // adobeRGB coefficients\n\n// Derived from:\n// xW\tyW\tK\txR\tyR\txG\tyG\txB\tyB\n// 0.312720\t0.329030\t6504\t0.640\t0.330\t0.210\t0.710\t0.150\t0.060\n\n         // linearize r, g, or b then apply coefficients\n        // and sum then return the resulting luminance\n\n  function simpleExp (chan) { return Math.pow(chan/255.0, mainTRC); };\n\n  return sRco * simpleExp(rgb[0]) +\n         sGco * simpleExp(rgb[1]) +\n         sBco * simpleExp(rgb[2]);\n\n} // End displayP3toY()\n\n\n\n\n////////////////////////////////////////////////////////////////////////////\n//////////  UTILITIES  \\///////////////////////////////////////////////////\n\n\n//////////  ∆í  alphaBlend()  /////////////////////////////////////////////\n\n                      // send rgba array for text/icon, rgb for background.\n                     // Only foreground allows alpha of 0.0 to 1.0 \n                    // This blends using gamma encoded space (standard)\n                   // rounded 0-255 or set round=false for number 0.0-255.0\nfunction alphaBlend (rgbaFG=[0,0,0,1.0], rgbBG=[0,0,0], round = true ) {\n\t\n\trgbaFG[3] = Math.max(Math.min(rgbaFG[3], 1.0), 0.0); // clamp alpha 0-1\n\tlet compBlend = 1.0 - rgbaFG[3];\n\tlet rgbOut = [0,0,0,1,true]; // or just use rgbBG to retain other elements?\n\t\n\tfor (let i=0;i<3;i++) {\n\t\trgbOut[i] = rgbBG[i] * compBlend + rgbaFG[i] * rgbaFG[3];\n\t\tif (round) rgbOut[i] = Math.min(Math.round(rgbOut[i]),255);\n\t};\n  return rgbOut;\n} // End alphaBlend()\n\n\n\n\n//\\                                     ////////////////////////////////////////\n///\\                                   ////////////////////////////////////////\n////\\                                 ////////////////////////////////////////\n/////\\  END APCA 0.1.9  G-4g  BLOCK  ////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\n//# sourceURL=webpack:///./node_modules/apca-w3/src/apca-w3.js?");

/***/ }),

/***/ "./node_modules/colorparsley/src/colorparsley.js":
/*!*******************************************************!*\
  !*** ./node_modules/colorparsley/src/colorparsley.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorParsley: () => (/* binding */ colorParsley),\n/* harmony export */   colorToHex: () => (/* binding */ colorToHex),\n/* harmony export */   colorToRGB: () => (/* binding */ colorToRGB)\n/* harmony export */ });\n///////////////////////////////////////////////////////////////////////////////\n/** @preserve\n/////    CoLoR PaRsLeY  a simple set of color parsing thingies!\n/////           Beta 0.1.8   Revision date: June 04, 2022\n/////\n/////    Functions to parse color values and return array\n/////    Copyright (c) 2019-2022 by Andrew Somers. All Rights Reserved.\n/////    LICENSE: AGPL 3\n/////    CONTACT: Please use the ISSUES or DISCUSSIONS tab at:\n/////    https://github.com/Myndex/colorparsley/\n/////\n///////////////////////////////////////////////////////////////////////////////\n/////\n/////    IMPORT:\n/////    import { colorParsley } from 'colorparsley';\n/////\n/////    let rgbaArray = colorParsley('#abcdef');\n/////\n/////    Output as array:  [r,g,b,a,isValid,colorspace]\n/////    Example: [123,123,123,1.0,true,'sRGB']\n// */\n///////////////////////////////////////////////////////////////////////////////\n\n// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// @output_file_name colorparsley.min.js\n// @code_url https://raw.githubusercontent.com/Myndex/colorparsley/master/src/colorparsley.js\n// ==/ClosureCompiler==\n\n// \n////////////////////////////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n/////  BEGIN COLOR PARSLEY 0.1.8  BLOCK  \\/////////////////////////////////////\n////                                      \\///////////////////////////////////\n///                                        \\/////////////////////////////////\n\n\n/////  ∆í  colorParsley()  ///////////////////////////////////////////////////\n\nfunction colorParsley (colorIn) {\n\n    if (typeof colorIn === 'string') {\n        return parseString(colorIn);\n    } else if (typeof colorIn === 'number') {\n        return [(colorIn & 0xFF0000) >> 16,\n                (colorIn & 0x00FF00) >> 8,\n                (colorIn & 0x0000FF), 1, true, 'unknown'];\n    } else if (typeof colorIn === 'object') {\n       if (Array.isArray(colorIn)) {\n          return colorIn;\n       } else if (!isNaN(colorIn.r) || !isNaN(colorIn.red)){\n              // validate object & return array\n         let objArray = [0,0,0,0,false,'unknown'];\n             // takes object with r g b or red green blue etc...\n         objArray[0] = (colorIn.r)?colorIn.r:(colorIn.red)?\n                        colorIn.red:false;\n         objArray[1] = (colorIn.g)?colorIn.g:(colorIn.green)?\n                        colorIn.green:false;\n         objArray[2] = (colorIn.b)?colorIn.b:(colorIn.blue)?\n                        colorIn.blue:false;\n         objArray[3] = (colorIn.a)?colorIn.a:(colorIn.alpha)?\n                        colorIn.alpha:1;\n         objArray[4] = (objArray[0]&&objArray[1]&&objArray[2]) ? true : false;\n         objArray[5] =\n            (colorIn.space)?colorIn.space:\n            (colorIn.colorSpace)?colorIn.colorSpace:\n            (colorIn.colorspace)?colorIn.colorspace:\n            'unknown';\n         \n         return objArray;\n       }\n    }; // End if statement\n        console.log('colorParsley error: invalid input')\n        return [0,0,0,0,false,'inputError'] // throw 'InvalidInput' // return error \n};\n\n\n/////  ∆í  parseString()  ///////////////////////////////////////////////////\n\n// private\nfunction parseString (colorString = '#abcdef') {\n\n                 // strip junk and make a clean string (replace unmatched)\n                // This retains all alphanumeric and , . # % ( ) /\n  colorString = colorString.replace(/[^\\w,.#%()\\/ -]/g,'');\n  colorString = colorString.toLowerCase();   // set lowercase\n  \n  let isValid = false; // validation flag, in array element [4]\n  let type = 'sRGB'; // Default colorspace flag in element [5]\n  let retArray = [0,0,0,0,isValid,type]; // init the return array\n\n\n      // test for named color before iterating array\n  if (colorString.match(/^(?:(?!rgb|l.h|hs|col|\\d|#).{0,4})(?=[g-z])/)) {\n\n\n    ///// CSS4 NAMED COLORS plus a bonus set of GREYS and GRAYS //////////\n    \n        // If name is matched, parse and return the color values\n    let namedColors = {\n    gray0:'000000',gray1:'111111',gray2:'222222',gray3:'333333',gray4:'444444',gray5:'555555',gray6:'666666',gray7:'777777',gray8:'888888',gray9:'999999',graya:'aaaaaa',grayb:'bbbbbb',grayc:'cccccc',grayd:'dddddd',graye:'eeeeee',grayf:'ffffff',midgray:'a0a0a0',\n    grey0:'000000',grey1:'111111',grey2:'222222',grey3:'333333',grey4:'444444',grey5:'555555',grey6:'666666',grey7:'777777',grey8:'888888',grey9:'999999',greya:'aaaaaa',greyb:'bbbbbb',greyc:'cccccc',greyd:'dddddd',greye:'eeeeee',greyf:'ffffff',midgrey:'a0a0a0',\n    aliceblue:'f0f8ff',antiquewhite:'faebd7',aqua:'00ffff',aquamarine:'7fffd4',azure:'f0ffff',\n    beige:'f5f5dc',bisque:'ffe4c4',black:'000000',blanchedalmond:'ffebcd',blue:'0000ff',blueviolet:'8a2be2',brown:'a52a2a',burlywood:'deb887',\n    cadetblue:'5f9ea0',chartreuse:'7fff00',chocolate:'d2691e',coral:'ff7f50',cornflowerblue:'6495ed',cornsilk:'fff8dc',crimson:'dc143c',cyan:'00ffff',\n    darkblue:'00008b',darkcyan:'008b8b',darkgoldenrod:'b8860b',darkgray:'a9a9a9',darkgreen:'006400',darkgrey:'a9a9a9',darkkhaki:'bdb76b',darkmagenta:'8b008b',darkolivegreen:'556b2f',darkorange:'ff8c00',darkorchid:'9932cc',darkred:'8b0000',darksalmon:'e9967a',darkseagreen:'8fbc8f',darkslateblue:'483d8b',darkslategray:'2f4f4f',darkslategrey:'2f4f4f',darkturquoise:'00ced1',darkviolet:'9400d3',deeppink:'ff1493',deepskyblue:'00bfff',dimgray:'696969',dimgrey:'696969',dodgerblue:'1e90ff',\n    firebrick:'b22222',floralwhite:'fffaf0',forestgreen:'228b22',fuchsia:'ff00ff',\n    gainsboro:'dcdcdc',ghostwhite:'f8f8ff',gold:'ffd700',goldenrod:'daa520',gray:'808080',green:'008000',greenyellow:'adff2f',grey:'808080',\n    honeydew:'f0fff0',hotpink:'ff69b4',\n    indianred:'cd5c5c',indigo:'4b0082',ivory:'fffff0',\n    khaki:'f0e68c',\n    lavender:'e6e6fa',lavenderblush:'fff0f5',lawngreen:'7cfc00',lemonchiffon:'fffacd',lightblue:'add8e6',lightcoral:'f08080',lightcyan:'e0ffff',lightgoldenrodyellow:'fafad2',lightgray:'d3d3d3',lightgreen:'90ee90',lightgrey:'d3d3d3',lightpink:'ffb6c1',lightsalmon:'ffa07a',lightseagreen:'20b2aa',lightskyblue:'87cefa',lightslategray:'778899',lightslategrey:'778899',lightsteelblue:'b0c4de',lightyellow:'ffffe0',lime:'00ff00',limegreen:'32cd32',linen:'faf0e6',\n    magenta:'ff00ff',maroon:'800000',mediumaquamarine:'66cdaa',mediumblue:'0000cd',mediumorchid:'ba55d3',mediumpurple:'9370db',mediumseagreen:'3cb371',mediumslateblue:'7b68ee',mediumspringgreen:'00fa9a',mediumturquoise:'48d1cc',mediumvioletred:'c71585',midnightblue:'191970',mintcream:'f5fffa',mistyrose:'ffe4e1',moccasin:'ffe4b5',\n    navajowhite:'ffdead',navy:'000080',\n    oldlace:'fdf5e6',olive:'808000',olivedrab:'6b8e23',orange:'ffa500',orangered:'ff4500',orchid:'da70d6',\n    palegoldenrod:'eee8aa',palegreen:'98fb98',paleturquoise:'afeeee',palevioletred:'db7093',papayawhip:'ffefd5',peachpuff:'ffdab9',peru:'cd853f',pink:'ffc0cb',plum:'dda0dd',powderblue:'b0e0e6',purple:'800080',\n    rebeccapurple:'663399',red:'ff0000',rosybrown:'bc8f8f',royalblue:'4169e1',\n    saddlebrown:'8b4513',salmon:'fa8072',sandybrown:'f4a460',seagreen:'2e8b57',seashell:'fff5ee',sienna:'a0522d',silver:'c0c0c0',skyblue:'87ceeb',slateblue:'6a5acd',slategray:'708090',slategrey:'708090',snow:'fffafa',springgreen:'00ff7f',steelblue:'4682b4',\n    tan:'d2b48c',teal:'008080',thistle:'d8bfd8',tomato:'ff6347',turquoise:'40e0d0',\n    violet:'ee82ee',\n    wheat:'f5deb3',white:'ffffff',whitesmoke:'f5f5f5',\n    yellow:'ffff00',yellowgreen:'9acd32'\n    };\n\n    for (let key in namedColors) {\n      if (colorString == key) {\n\n        let hexRex = {  \n          rex: /^([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/,\n          sprig: function (slices) {\n            for (let i = 0; i < 3; i++) {\n              retArray[i] = parseInt(slices[i+1],16);\n            }\n            retArray[3] = 1;\n            return true;\n          }\n        };\n\n        let hexProc = hexRex.rex.exec(namedColors[key]);\n        retArray[4] = isValid = hexRex.sprig(hexProc);\n\n        return retArray;\n      }\n    }\n  };   // end of named colors section\n\n\n       // NEW regex  0.1.6 - still current for use with with 0.1.8+\n      // See docs for breakdown of regex pattern\n  let colorRex = {\n    rex: /(?:^(?:#|0x|)(?:(?:([\\da-f])([\\da-f])([\\da-f])([\\da-f])?)(?!\\S)|(?:([\\da-f]{2})(?:([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})?)?))|(?:(?:^(?:rgba?|)\\(? ?(?:(?:(?:(255|(?:25[0-4]|2[0-4]\\d|1?\\d{1,2})(?:\\.\\d{1,24})?)))(?:,[^\\S]*$|(?:(?:, ?| )(255|(?:25[0-4]|2[0-4]\\d|1?\\d{1,2})(?:\\.\\d{1,24})?)(?:, ?| )(255|(?:25[0-4]|2[0-4]\\d|1?\\d{1,2})(?:\\.\\d{1,24})?)))|(100%|\\d{1,2}(?:\\.\\d{1,24})?%)(?:,?[^\\S]*$|(?:(?:, ?| )(?:(100%|\\d{1,2}(?:\\.\\d{1,24})?%)(?:, ?| )(100%|\\d{1,2}(?:\\.\\d{1,24})?%)))))|^(?:color\\((srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|xyz|xyz-d50|xyz-d65) (?:(100%|\\d{1,2}(?:\\.\\d{1,24})?%|[0 ]\\.\\d{1,24}|[01])) (?:(100%|\\d{1,2}(?:\\.\\d{1,24})?%|[0 ]\\.\\d{1,24}|[01])) (?:(100%|\\d{1,2}(?:\\.\\d{1,24})?%|[0 ]\\.\\d{1,24}|[01])))|^(?:((?:r(?!gb)|c(?!olor)|[abd-qs-z])[a-z]{2,5})\\( ?((?:\\d{0,3}\\.|)\\d{1,24}%?)(?:, ?| )((?:\\d{0,3}\\.|)\\d{1,24}%?)(?:, ?| )((?:\\d{0,3}\\.|)\\d{1,24}%?))))(?:(?:,| \\/| ) ?(?:(100%|\\d{1,2}(?:\\.\\d{1,24})?%|[0 ]\\.\\d{1,24}|[01])))?(?:\\)| |))[^\\S]*$/,\n\n\n    parsley: function (slices) {\n\n      let slicePos = 0;\n      let sliceLast = 0;\n      let base = 10;\n      let divisor = 100.0;\n      let convertPct = 2.55;\n      let alpha = '1';\n\n\n      if (slices[23]) {\n        alpha = slices[23];\n        delete slices[23];\n      }\n                     // Set alpha before anything else\n      retArray[3] = (alpha.match(/%/g)) ?\n                    parseFloat(alpha) / divisor :\n                    parseFloat(alpha);\n\n                    //  determine first and last element\n      for (let k=1; k < slices.length; k++) { \n        if (slices[k]) {\n          slicePos = (slicePos) ? slicePos : k;\n          sliceLast = k;\n        }\n      }\n\n  switch (sliceLast) {\n\n    case 4:  // This is the 3-4 digit hex parsing\n      base = 16;\n      divisor = 15.0;\n      retArray[3] = parseInt(slices[sliceLast],base) / divisor ;\n    case 3:\n      base = 16;\n      for (let i = 0; i < 3; i++) {\n        retArray[i] = parseInt(slices[slicePos+i] + slices[slicePos+i],base);\n      }\n    break;\n\n    case 5:    // allows two digit hex to become grey\n      base = 16;\n    case 9:  // allows 1-3 digit INT with comma to become grey\n      retArray[0] = retArray[1] = retArray[2] = \n        (base == 10) ? parseFloat(slices[sliceLast]) : \n                       parseInt(slices[sliceLast],base);\n    break;\n\n    case 12:  // allows single percentage to become grey\n      retArray[0] = retArray[1] = retArray[2] = \n         parseFloat(slices[sliceLast]) * convertPct;\n    break;\n\n    case 8:  // These are the main parsings for hex and rgb()\n      base = 16;\n      divisor = 255.0;\n      retArray[3] = parseInt(slices[8],base) / divisor ;\n    case 7:\n      base = 16;\n    case 11:\n      for (let i = 0; i < 3; i++) {\n        retArray[i] = (base == 10) ? parseFloat(slices[slicePos+i]) :\n                                  parseInt(slices[slicePos+i],base);\n      }\n    break;\n\n    case 14: //  rgb() percentage\n      for (let i = 0; i < 3; i++) {\n        retArray[i] = parseFloat(slices[slicePos+i]) * convertPct;\n      }\n    break;\n    \n    case 18:  // This is for color() CSS 4\n      retArray[5] = slices[15];\n\n      for (let i = 0; i < 3; i++) { // color() is converted to 0.0-255.0\n        slicePos++;\n        retArray[i] = (slices[slicePos].match(/%/g)) ?\n            parseFloat(slices[slicePos]) * 2.55:\n            parseFloat(slices[slicePos]) * 255;  \n      }\n    break;\n\n    case 22: // This is the \"wild west\" section\n\n      retArray[5] = slices[slicePos];\n\n      for (let i = 0; i < 3; i++ ) {\n        slicePos++;\n        retArray[i] = (slices[slicePos]) ? (slices[slicePos].match(/%/g)) ?\n            parseFloat(slices[slicePos]) / divisor :\n            parseFloat(slices[slicePos]) : 0.0 ;\n      }\n\n          // Process for HSL and HWB\n      if (retArray[5].match(/^(?:hsla?|hwba?)/i) ) {\n        let sat,light,white,black,hwbFact;\n\n        let hue = retArray[0] % 360.0;\n        if (hue < 0) { hue += 360.0; }\n\n        if (retArray[5].match(/^hsla?/i) ) {\n          sat   = retArray[1];\n          light = retArray[2];\n          white = 0;\n          hwbFact = 1; \n        } else if (retArray[5].match(/^hwba?/i) ) {\n          white = retArray[1];\n          black = retArray[2];\n\n          if (white + black >= 1) {\n            retArray[0] = retArray[1] = retArray[2] = white / (white + black);\n            retArray[5] = 'sRGB';\n            break;\n          }\n\n          sat = 1.0;\n          light = 0.5;\n          hwbFact = (1.0 - white - black);\n        }\n\n        function f(n) {  // from CSS reference implementation\n          let k = (n + hue/30) % 12;\n          let a = sat * Math.min(light, 1 - light);\n          return light - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n        }\n\n        retArray[0] = Math.round(255 * (f(0) * hwbFact + white));\n        retArray[1] = Math.round(255 * (f(8) * hwbFact + white));\n        retArray[2] = Math.round(255 * (f(4) * hwbFact + white));\n        retArray[5] = 'sRGB';\n      }\n      break;\n      }\n      return true;\n    }  // close parsley sub-function\n  };  // close colorRex obj\n\n\n      //  The main call\n  let slicesProc = colorRex.rex.exec(colorString);\n\n  if (slicesProc) { // Error catch\n    \n    retArray[4] = isValid = colorRex.parsley(slicesProc); // set the isValid flag\n\n    return retArray;\n\n  } else {\n    isValid = false;\n    console.log('colorParsley error: unable to parse string')\n    return [0,0,0,0,isValid,'parsleyError']  // throw 'InvalidString'\n  }\n};\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n/////  BONUS STRING FORMATTING UTILITIES  \\////////////////////////////////////\n\n\n/////  ∆í  colorToHex()  ///////////////////////////////////////////////////\n\n    // returns hex string, 3,4,6, or 8 chars if that was entered, no #\n    // If alpha is 1 or empty, no alpha is returned i.e. abcf returns abc\n    \nfunction colorToHex (rgba = [0,0,0,''], allow3 = true) {\n    let R = Math.round(rgba[0]).toString(16).padStart(2, '0');\n    let G = Math.round(rgba[1]).toString(16).padStart(2, '0');\n    let B = Math.round(rgba[2]).toString(16).padStart(2, '0');\n    let A = (rgba[3] == '' || rgba[3] == 1) ? '' :\n             Math.round(rgba[3] * 255).toString(16).padStart(2, '0') ;\n\n         // this if returns a 3 character hex if possible - aabbcc becomes abc\n    if ( allow3 &&\n         parseInt(A, 16) % 17 == 0 &&\n         parseInt(A, 16) % 17 == 0 &&\n         parseInt(A, 16) % 17 == 0 &&\n         (parseInt(A, 16) % 17 == 0 || A == '')\n         ) {\n         return R.charAt(0) + G.charAt(0) + B.charAt(0) + A.charAt(0);\n    } else {\n      return R + G + B + A;\n    }\n}\n\n\n\n\n/////  ∆í  colorToRGB()  ///////////////////////////////////////////////////\n\n    // RGBAstr ‚Äî returns rgb() or rgba() INT value string (0-255) no spaces\n    // If alpha is 1 or empty, no alpha is returned \n    \nfunction colorToRGB (rgba = [0,0,0,''], round = true) {\n    if (round) {\n      for (let i=0; i < 3; i++) {\n        rgba[i] = Math.round(rgba[i]);\n      } \n                // while RGB tuples round to int, A needs additional precision\n      rgba[3] = ( rgba[3] == '' || rgba[3] == 1) ? 1 :\n                  Math.trunc(rgba[3]*1000)*0.001; \n    }\n\n    return ( rgba[3] == '' || rgba[3] == 1) ? \n      'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')' :\n      'rgba(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ',' + rgba[3] + ')';\n}\n\n\n/////\\  END UTILITIES  ///////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n\n///\\                                      //////////////////////////////////////\n////\\                                    //////////////////////////////////////\n/////\\  END COLOR PARSLEY 0.1.8  BLOCK  //////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n//# sourceURL=webpack:///./node_modules/colorparsley/src/colorparsley.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/main.js");
/******/ 	
/******/ })()
;